import streamlit as st
import json
import os
import time
import random
import string

from dotenv import load_dotenv

load_dotenv()

# Check if the deployment is running in Streamlit Sharing



st.set_page_config(page_title="PhytoOracle Analytics", layout="wide")

placeholder = st.empty()

if os.getenv("DEPLOYMENT_STATUS") != "complete":
    def generate_password(length=15):
        """Generate a random password with given length."""
        while True:
            characters = string.ascii_letters + string.digits + string.punctuation
            password = ''.join(random.choice(characters) for _ in range(length))
            # Ensure the password has at least one digit, one special character, one lowercase, and one uppercase character
            if (any(c.isdigit() for c in password) and
                any(c.islower() for c in password) and
                any(c.isupper() for c in password) and
                any(c in string.punctuation for c in password)):
                return password
    
    # passwd_default = generate_password()


    with placeholder.container():
        while True:
            # # print all environment variables
            # for key, value in os.environ.items():
            #     print(f"{key}: {value}")

            st.title("Deployment Parameters & Log Viewer")

            # --- Configuration Section ---
            if "submitted" not in st.session_state:
                st.session_state.submitted = False

            # If the config file exists, then set the submitted flag to True
            if os.path.exists("/app/config.json"):
                st.session_state.submitted = True

            # if an ERROR env variable exists, then set the submitted flag to False
            if os.getenv("ERROR") is not None:
                st.warning(os.getenv("ERROR"))
                # remove the ERROR env variable - from the system
                os.unsetenv("ERROR")
                del os.environ["ERROR"]
                st.session_state.submitted = False


            if not st.session_state.submitted:
                irods_user = st.text_input("CyVerse Username", value= os.getenv("IPLANT_USER", ""))
                irods_password = st.text_input("CyVerse Password", type="password")

                # st.markdown("""
                # ### OpenSearch Password Guidelines
                # - Must be at least 8 characters long
                # - Should include both uppercase and lowercase letters
                # - Should contain at least one number
                # - Should have at least one special character (e.g., @, #, $, etc.)
                
                # **The autogenerated password shown below follows these guidelines.**
                # """)
                
                # elastic_password = st.text_input("OpenSearch Password", type="password", value=passwd_default)
                # elastic_password = passwd_default

                # Ask the user if they want to update the opensearch JSON data from iRODS
                st.markdown("""
                ### Update OpenSearch Data
                - If you want to update the OpenSearch data from iRODS, check the box below.
                - This will update the data in OpenSearch with the latest data from iRODS.
                - **This process may take a while depending on the amount of data.**
                """)
                update_data = st.checkbox("Update OpenSearch Data")
                
                time_consumed = "1-2 minutes" if not update_data else "30 minutes"
                st.info(f"Based on the current configuration, the deployment will take approximately {time_consumed}.")
                if st.button("Submit"):
                    if not irods_user or not irods_password: # or not elastic_password:
                        st.error("Please fill in all fields.")
                    else:
                        config = {
                            "IRODS_USER": irods_user,
                            "IRODS_PASSWORD": irods_password,
                            # "ELASTIC_PASSWORD": elastic_password,
                            "UPDATE_DATA": update_data
                        }
                        with open("/app/config.json", "w") as f:
                            json.dump(config, f)
                        st.success("Parameters saved! The deployment will continue shortly.")
                        st.session_state.submitted = True

            # --- Tail-like Log Viewer Section ---
            st.subheader("Deployment Log (Tail View)")

            LOG_FILE = "/app/progress.log"
            OPENSEARCH_LOG = "/app/opensearch_output.log"

            def tail(filepath, lines=20):
                """Return the last 'lines' of the file."""
                if not os.path.exists(filepath):
                    return "Log file not available yet."
                try:
                    with open(filepath, "r") as f:
                        all_lines = f.readlines()
                        return "".join(all_lines[-lines:])
                except Exception as e:
                    return f"Error reading log: {e}"


            c1, c2 = st.columns(2)
            with c1:
                st.subheader("Deployment Progress")
                log_placeholder = st.empty()
                lf_tail = tail(LOG_FILE)
                log_placeholder.text(lf_tail)
            with c2:
                st.subheader("OpenSearch Output")
                opensearch_placeholder = st.empty()
                opensearch_placeholder.text(tail(OPENSEARCH_LOG))
            
            # if the last line of the log file (after removing whitespace) is term_loop, then the deployment is complete
            if lf_tail.split()[-1].strip() == "term_loop":
                os.putenv("DEPLOYMENT_STATUS", "complete")
                os.environ["DEPLOYMENT_STATUS"] = "complete"
                st.success("Deployment complete! You can now access the app. If you encounter an error message, please refresh the page.")
                # add a timer before the app loads, with a countdown
                st.balloons()
                info = st.empty()
                for i in range(30, 0, -1):
                    info.info(f"Loading app in {i} seconds...")
                    time.sleep(1)
                info.empty()
                st.success("App loaded successfully!")
                break

            # Auto-refresh the app every 2 seconds to simulate "tail -f".
            time.sleep(2)
            st.rerun()

# If the deployment is not in progress, continue with the app
from main import app


with placeholder.container():
    app()